var documenterSearchIndex = {"docs":
[{"location":"generated/simple/","page":"Simple","title":"Simple","text":"EditURL = \"../../../examples/simple.jl\"","category":"page"},{"location":"generated/simple/","page":"Simple","title":"Simple","text":"# Simple 2D example from (Kelley2003)[@cite]\n\nusing NewtonKrylov, LinearAlgebra\nusing CairoMakie\n\nfunction F!(res, x, p)\n    res[1] = x[1]^2 + x[2]^2 - 2\n    return res[2] = exp(x[1] - 1) + x[2]^2 - 2\nend\n\nfunction F(x, p)\n    res = similar(x)\n    F!(res, x, p)\n    return res\nend\n\n\nxs = LinRange(-3, 8, 1000)\nys = LinRange(-15, 10, 1000)\n\nlevels = [0.1, 0.25, 0.5:2:10..., 10.0:10:200..., 200:100:4000...]\n\nfig, ax = contour(xs, ys, (x, y) -> norm(F([x, y], nothing)); levels)\n\ntrace_1 = let x₀ = [2.0, 0.5]\n    xs = Vector{Tuple{Float64, Float64}}(undef, 0)\n    hist(x, res, n_res) = (push!(xs, (x[1], x[2])); nothing)\n    x, stats = newton_krylov!(F!, x₀, nothing, callback = hist)\n    xs\nend\nlines!(ax, trace_1)\n\ntrace_2 = let x₀ = [2.5, 3.0]\n    xs = Vector{Tuple{Float64, Float64}}(undef, 0)\n    hist(x, res, n_res) = (push!(xs, (x[1], x[2])); nothing)\n    x, stats = newton_krylov!(F!, x₀, nothing, callback = hist)\n    xs\nend\nlines!(ax, trace_2)\n\ntrace_3 = let x₀ = [3.0, 4.0]\n    xs = Vector{Tuple{Float64, Float64}}(undef, 0)\n    hist(x, res, n_res) = (push!(xs, (x[1], x[2])); nothing)\n    x, stats = newton_krylov!(F!, x₀, nothing, callback = hist, forcing = NewtonKrylov.EisenstatWalker(η_max = 0.68949), verbose = 1)\n    @show stats.solved\n    xs\nend\nlines!(ax, trace_3)\n\nfig","category":"page"},{"location":"generated/simple/","page":"Simple","title":"Simple","text":"","category":"page"},{"location":"generated/simple/","page":"Simple","title":"Simple","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"EditURL = \"../../../examples/bratu.jl\"","category":"page"},{"location":"generated/bratu/#1D-bratu-equation-from-(Kan2022-ko)[@cite]","page":"Bratu – 1D","title":"1D bratu equation from (Kan2022-ko)[@cite]","text":"","category":"section"},{"location":"generated/bratu/#Necessary-packages","page":"Bratu – 1D","title":"Necessary packages","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"using NewtonKrylov, Krylov\nusing KrylovPreconditioners\nusing SparseArrays, LinearAlgebra\nusing CairoMakie","category":"page"},{"location":"generated/bratu/#1D-Bratu-equations","page":"Bratu – 1D","title":"1D Bratu equations","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"y + λ * exp(y) = 0","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"F(u) = 0","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"function bratu!(res, y, (Δx, λ))\n    N = length(y)\n    for i in 1:N\n        y_l = i == 1 ? zero(eltype(y)) : y[i - 1]\n        y_r = i == N ? zero(eltype(y)) : y[i + 1]\n        y′′ = (y_r - 2y[i] + y_l) / Δx^2\n\n        res[i] = y′′ + λ * exp(y[i]) # = 0\n    end\n    return nothing\nend\n\nfunction bratu(y, p)\n    res = similar(y)\n    bratu!(res, y, p)\n    return res\nend","category":"page"},{"location":"generated/bratu/#Reference-solution","page":"Bratu – 1D","title":"Reference solution","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"function true_sol_bratu(x)\n    # for λ = 3.51382, 2nd sol θ = 4.8057\n    θ = 4.79173\n    return -2 * log(cosh(θ * (x - 0.5) / 2) / (cosh(θ / 4)))\nend","category":"page"},{"location":"generated/bratu/#Choice-of-parameters","page":"Bratu – 1D","title":"Choice of parameters","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"const N = 10_000\nconst λ = 3.51382\nconst dx = 1 / (N + 1) # Grid-spacing","category":"page"},{"location":"generated/bratu/#Domain-and-Inital-condition","page":"Bratu – 1D","title":"Domain and Inital condition","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"x = LinRange(0.0 + dx, 1.0 - dx, N)\nu₀ = sin.(x .* π)\n\nlines(x, u₀, label = \"Inital guess\")","category":"page"},{"location":"generated/bratu/#Reference-solution-evaluated-over-domain","page":"Bratu – 1D","title":"Reference solution evaluated over domain","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"reference = true_sol_bratu.(x)\n\nfig, ax = lines(x, u₀, label = \"Inital guess\")\nlines!(ax, x, reference, label = \"Reference solution\")\naxislegend(ax, position = :cb)\nfig","category":"page"},{"location":"generated/bratu/#Solving-using-inplace-variant-and-CG","page":"Bratu – 1D","title":"Solving using inplace variant and CG","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"uₖ, _ = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = CgSolver,\n)\n\nϵ = abs2.(uₖ .- reference)\n\nlet\n    fig = Figure(size = (800, 800))\n    ax = Axis(fig[1, 1], title = \"\", ylabel = \"\", xlabel = \"\")\n\n    lines!(ax, x, reference, label = \"True solution\")\n    lines!(ax, x, u₀, label = \"Initial guess\")\n    lines!(ax, x, uₖ, label = \"Newton-Krylov solution\")\n\n    axislegend(ax, position = :cb)\n\n    ax = Axis(fig[1, 2], title = \"Error\", ylabel = \"abs2 err\", xlabel = \"\")\n    lines!(ax, abs2.(uₖ .- reference))\n\n    fig\nend","category":"page"},{"location":"generated/bratu/#Solving-using-the-out-of-place-variant","page":"Bratu – 1D","title":"Solving using the out of place variant","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov(\n    bratu,\n    copy(u₀), (dx, λ);\n    Solver = CgSolver\n)\nstats","category":"page"},{"location":"generated/bratu/#Solving-with-a-fixed-forcing","page":"Bratu – 1D","title":"Solving with a fixed forcing","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = CgSolver,\n    forcing = NewtonKrylov.Fixed(0.1)\n)\nstats","category":"page"},{"location":"generated/bratu/#Solving-with-no-forcing","page":"Bratu – 1D","title":"Solving with no forcing","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = CgSolver,\n    forcing = nothing\n)\nstats","category":"page"},{"location":"generated/bratu/#Solve-using-GMRES-–-doesn't-converge","page":"Bratu – 1D","title":"Solve using GMRES – doesn't converge","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = GmresSolver,\n)\nstats","category":"page"},{"location":"generated/bratu/#Solve-using-GMRES-ILU-Preconditoner","page":"Bratu – 1D","title":"Solve using GMRES + ILU Preconditoner","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = GmresSolver,\n    N = (J) -> ilu(collect(J)), # Assembles the full Jacobian\n    krylov_kwargs = (; ldiv = true)\n)\nstats","category":"page"},{"location":"generated/bratu/#Solve-using-FGMRES-ILU-Preconditoner","page":"Bratu – 1D","title":"Solve using FGMRES + ILU Preconditoner","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = FgmresSolver,\n    N = (J) -> ilu(collect(J)), # Assembles the full Jacobian\n    krylov_kwargs = (; ldiv = true)\n)\nstats","category":"page"},{"location":"generated/bratu/#Solve-using-FGMRES-GMRES-Preconditoner","page":"Bratu – 1D","title":"Solve using FGMRES + GMRES Preconditoner","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"struct GmresPreconditioner{JOp}\n    J::JOp\n    itmax::Int\nend\n\nfunction LinearAlgebra.mul!(y, P::GmresPreconditioner, x)\n    sol, _ = gmres(P.J, x; P.itmax)\n    return copyto!(y, sol)\nend\n\n_, stats = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = FgmresSolver,\n    N = (J) -> GmresPreconditioner(J, 5),\n)\nstats","category":"page"},{"location":"generated/bratu/#Explodes..","page":"Bratu – 1D","title":"Explodes..","text":"","category":"section"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"newton_krylov!(\n\tbratu!,\n\tcopy(u₀), (dx, λ), similar(u₀);\n\tSolver = CglsSolver, # CgneSolver\n  krylov_kwargs = (; verbose=1)\n)","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"newton_krylov!(\n\tbratu!,\n\tcopy(u₀), (dx, λ), similar(u₀);\n\tverbose = 1,\n\tSolver = BicgstabSolver, # L=2\n\tη_max = nothing\n)","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"","category":"page"},{"location":"generated/bratu/","page":"Bratu – 1D","title":"Bratu – 1D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"EditURL = \"../../../examples/implicit_timedependent.jl\"","category":"page"},{"location":"generated/implicit_timedependent/#Implicit-time-integration","page":"Implicit","title":"Implicit time-integration","text":"","category":"section"},{"location":"generated/implicit_timedependent/#Necessary-packages","page":"Implicit","title":"Necessary packages","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"using NewtonKrylov\nusing CairoMakie","category":"page"},{"location":"generated/implicit_timedependent/#Implicit-schemes","page":"Implicit","title":"Implicit schemes","text":"","category":"section"},{"location":"generated/implicit_timedependent/#Implicit-Euler","page":"Implicit","title":"Implicit Euler","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"function G_Euler!(res, f, y, yₙ, t, Δt)\n    return res .= yₙ .+ Δt .* f(y, t) .- y\nend","category":"page"},{"location":"generated/implicit_timedependent/#Implicit-Midpoint","page":"Implicit","title":"Implicit Midpoint","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"function G_Midpoint!(res, f, y, yₙ, t, Δt)\n    return res .= yₙ .+ Δt .* f((yₙ .+ y) ./ 2, t + Δt / 2) .- y\nend","category":"page"},{"location":"generated/implicit_timedependent/#Implicit-Trapezoid","page":"Implicit","title":"Implicit Trapezoid","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"function G_Trapezoid!(res, f, y, yₙ, t, Δt)\n    return res .= yₙ .+ (Δt / 2) .* (f(yₙ, t) .+ f(y, t + Δt)) .- y\nend","category":"page"},{"location":"generated/implicit_timedependent/#Spring-equations","page":"Implicit","title":"Spring equations","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"function f(x, t, γ)\n    return [\n        x[2],     # dx/dt = v\n        -γ^2 * x[1],\n    ] # dv/dt = -γ^2 * x\nend","category":"page"},{"location":"generated/implicit_timedependent/#Non-adaptive-time-stepping","page":"Implicit","title":"Non-adaptive time stepping","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"function implicit_spring(G! = G_Euler!)\n    k = 2.0    # spring constant\n    m = 1.0    # object's mass\n    x0 = 0.1 # initial position\n    v0 = 0.0   # initial velocity\n\n    t₀ = 0.0\n    tₛ = 40.0\n    Δt = 0.01\n\n    ts = t₀:Δt:tₛ\n\n    yₙ = [x0, v0]\n\n    γ = sqrt(k / m)\n\n    hist = [copy(yₙ)]\n    for t in ts\n        if t == t₀\n            continue\n        end\n        F!(res, y, (yₙ, t, Δt)) = G!(res, (y, t) -> f(y, t, γ), y, yₙ, t, Δt)\n        y, _ = newton_krylov!(F!, copy(yₙ), (yₙ, t, Δt))\n        push!(hist, y)\n        yₙ .= y\n    end\n    return hist, ts\nend","category":"page"},{"location":"generated/implicit_timedependent/#Plots","page":"Implicit","title":"Plots","text":"","category":"section"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"hist_euler, ts_euler = implicit_spring(G_Euler!)\nv_euler = map(y -> y[1], hist_euler)\nx_euler = map(y -> y[2], hist_euler)\n\nhist_midpoint, ts_midpoint = implicit_spring(G_Midpoint!)\nv_midpoint = map(y -> y[1], hist_midpoint)\nx_midpoint = map(y -> y[2], hist_midpoint)\n\n\nhist_trapezoid, ts_trapezoid = implicit_spring(G_Trapezoid!)\nv_trapezoid = map(y -> y[1], hist_trapezoid)\nx_trapezoid = map(y -> y[2], hist_trapezoid)\n\n\nfig = Figure()\nax = fig[1, 1]\n\nlines(fig[1, 1], ts_euler, v_euler, label = \"Euler\")\nlines(fig[1, 2], ts_euler, x_euler, label = \"Euler\")\n\nlines(fig[2, 1], ts_midpoint, v_midpoint, label = \"Midpoint\")\nlines(fig[2, 2], ts_midpoint, x_midpoint, label = \"Midpoint\")\n\nlines(fig[3, 1], ts_trapezoid, v_trapezoid, label = \"Midpoint\")\nlines(fig[3, 2], ts_trapezoid, x_trapezoid, label = \"Midpoint\")\n\nfig","category":"page"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"","category":"page"},{"location":"generated/implicit_timedependent/","page":"Implicit","title":"Implicit","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#NewtonKrylov.jl","page":"Home","title":"NewtonKrylov.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Newton Method using Krylov.jl (montoison-orban-2023)[@cite]","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"newton_krylov!\nnewton_krylov","category":"page"},{"location":"#NewtonKrylov.newton_krylov!","page":"Home","title":"NewtonKrylov.newton_krylov!","text":"Arguments\n\nF!: F!(res, u, p) solves res = F(u) = 0\nu₀: Initial guess\np: Parameters\nM: Length of  the output of F!. Defaults to length(u₀)\n\nKeyword Arguments\n\ntol_rel: Relative tolerance\ntol_abs: Absolute tolerance\nmax_niter: Maximum number of iterations\nforcing: Maximum forcing term for inexact Newton.          If nothing an exact Newton method is used.  \nverbose:\nSolver:\nM:\nN:\nkrylov_kwarg\ncallback:\n\n\n\n\n\nArguments\n\nF!: F!(res, u, p) solves res = F(u) = 0\nu: Initial guess\np: \nres: Temporary for residual\n\nKeyword Arguments\n\ntol_rel: Relative tolerance\ntol_abs: Absolute tolerance\nmax_niter: Maximum number of iterations\nforcing: Maximum forcing term for inexact Newton.          If nothing an exact Newton method is used.  \nverbose:\nSolver:\nM:\nN:\nkrylov_kwarg\ncallback:\n\n\n\n\n\n","category":"function"},{"location":"#NewtonKrylov.newton_krylov","page":"Home","title":"NewtonKrylov.newton_krylov","text":"newton_krylov(F, u₀::AbstractArray, M::Int = length(u₀); kwargs...)\n\nArguments\n\nF: res = F(u₀, p) solves res = F(u₀) = 0\nu₀: Initial guess\np: Parameters\nM: Length of the output of F. Defaults to length(u₀).\n\nKeyword Arguments\n\ntol_rel: Relative tolerance\ntol_abs: Absolute tolerance\nmax_niter: Maximum number of iterations\nforcing: Maximum forcing term for inexact Newton.          If nothing an exact Newton method is used.  \nverbose:\nSolver:\nM:\nN:\nkrylov_kwarg\ncallback:\n\n\n\n\n\n","category":"function"},{"location":"#Parameters","page":"Home","title":"Parameters","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NewtonKrylov.Forcing\nNewtonKrylov.Fixed\nNewtonKrylov.EisenstatWalker","category":"page"},{"location":"#NewtonKrylov.Forcing","page":"Home","title":"NewtonKrylov.Forcing","text":"Forcing\n\nImplements forcing for inexact Newton-Krylov. The equation F(u)d + F(u) = η * F(u) gives the inexact Newton termination criterion.\n\nImplemented variants\n\nFixed\nEisenstatWalker\n\n\n\n\n\n","category":"type"},{"location":"#NewtonKrylov.Fixed","page":"Home","title":"NewtonKrylov.Fixed","text":"Fixed(η = 0.1)\n\n\n\n\n\n","category":"type"},{"location":"#NewtonKrylov.EisenstatWalker","page":"Home","title":"NewtonKrylov.EisenstatWalker","text":"EisenstatWalker(η_max = 0.999, γ = 0.9)\n\n\n\n\n\n","category":"type"},{"location":"#Internal","page":"Home","title":"Internal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NewtonKrylov.JacobianOperator","category":"page"},{"location":"#NewtonKrylov.JacobianOperator","page":"Home","title":"NewtonKrylov.JacobianOperator","text":"JacobianOperator\n\nEfficient implementation of J(f,x,p) * v and v * J(f, x,p)'\n\n\n\n\n\n","category":"type"},{"location":"#Bibliography","page":"Home","title":"Bibliography","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"EditURL = \"../../../examples/bratu_ka.jl\"","category":"page"},{"location":"generated/bratu_ka/#1D-bratu-equation-from-(Kan2022-ko)[@cite]","page":"Bratu – KernelAbstractions","title":"1D bratu equation from (Kan2022-ko)[@cite]","text":"","category":"section"},{"location":"generated/bratu_ka/#Necessary-packages","page":"Bratu – KernelAbstractions","title":"Necessary packages","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"using NewtonKrylov, Krylov\nusing KrylovPreconditioners\nusing SparseArrays, LinearAlgebra\nusing CairoMakie\nusing KernelAbstractions","category":"page"},{"location":"generated/bratu_ka/#1D-Bratu-equations","page":"Bratu – KernelAbstractions","title":"1D Bratu equations","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"y + λ * exp(y) = 0","category":"page"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"@kernel function bratu_kernel!(res, y, (Δx, λ))\n    i = @index(Global, Linear)\n    N = length(res)\n    y_l = i == 1 ? zero(eltype(y)) : y[i - 1]\n    y_r = i == N ? zero(eltype(y)) : y[i + 1]\n    y′′ = (y_r - 2y[i] + y_l) / Δx^2\n\n    res[i] = y′′ + λ * exp(y[i]) # = 0\nend\n\nfunction bratu!(res, y, p)\n    device = KernelAbstractions.get_backend(res)\n    kernel = bratu_kernel!(device)\n    kernel(res, y, p, ndrange = length(res))\n    return nothing\nend\n\nfunction bratu(y, p)\n    res = similar(y)\n    bratu!(res, y, p)\n    return res\nend","category":"page"},{"location":"generated/bratu_ka/#Reference-solution","page":"Bratu – KernelAbstractions","title":"Reference solution","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"function true_sol_bratu(x)\n    # for λ = 3.51382, 2nd sol θ = 4.8057\n    θ = 4.79173\n    return -2 * log(cosh(θ * (x - 0.5) / 2) / (cosh(θ / 4)))\nend","category":"page"},{"location":"generated/bratu_ka/#Choice-of-parameters","page":"Bratu – KernelAbstractions","title":"Choice of parameters","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"const N = 10_000\nconst λ = 3.51382\nconst dx = 1 / (N + 1) # Grid-spacing","category":"page"},{"location":"generated/bratu_ka/#Domain-and-Inital-condition","page":"Bratu – KernelAbstractions","title":"Domain and Inital condition","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"x = LinRange(0.0 + dx, 1.0 - dx, N)\nu₀ = sin.(x .* π)\n\nlines(x, u₀, label = \"Inital guess\")","category":"page"},{"location":"generated/bratu_ka/#Reference-solution-evaluated-over-domain","page":"Bratu – KernelAbstractions","title":"Reference solution evaluated over domain","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"reference = true_sol_bratu.(x)\n\nfig, ax = lines(x, u₀, label = \"Inital guess\")\nlines!(ax, x, reference, label = \"Reference solution\")\naxislegend(ax, position = :cb)\nfig","category":"page"},{"location":"generated/bratu_ka/#Solving-using-inplace-variant-and-CG","page":"Bratu – KernelAbstractions","title":"Solving using inplace variant and CG","text":"","category":"section"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"uₖ, _ = newton_krylov!(\n    bratu!,\n    copy(u₀), (dx, λ), similar(u₀);\n    Solver = CgSolver,\n)\n\nϵ = abs2.(uₖ .- reference)\n\nlet\n    fig = Figure(size = (800, 800))\n    ax = Axis(fig[1, 1], title = \"\", ylabel = \"\", xlabel = \"\")\n\n    lines!(ax, x, reference, label = \"True solution\")\n    lines!(ax, x, u₀, label = \"Initial guess\")\n    lines!(ax, x, uₖ, label = \"Newton-Krylov solution\")\n\n    axislegend(ax, position = :cb)\n\n    ax = Axis(fig[1, 2], title = \"Error\", ylabel = \"abs2 err\", xlabel = \"\")\n    lines!(ax, abs2.(uₖ .- reference))\n\n    fig\nend","category":"page"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"","category":"page"},{"location":"generated/bratu_ka/","page":"Bratu – KernelAbstractions","title":"Bratu – KernelAbstractions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/bvp/","page":"BVP","title":"BVP","text":"EditURL = \"../../../examples/bvp.jl\"","category":"page"},{"location":"generated/bvp/","page":"BVP","title":"BVP","text":"BVP from (Kelley2022)[@cite]","category":"page"},{"location":"generated/bvp/","page":"BVP","title":"BVP","text":"using NewtonKrylov, Krylov, LinearAlgebra\n\nfunction Phi(t, tdag, vp, v)\n    phi = 4.0 * tdag * vp + (t * v - 1.0) * v\n    return phi\nend\n\nfunction Fbvp!(res, U, (force, tv, tvdag, h, n))\n    @assert 2n == length(U)\n    res[1] = U[2]\n    res[2n] = U[2n - 1]\n    v = view(U, 1:2:(2n - 1))\n    vp = view(U, 2:2:2n)\n    force .= Phi.(tv, tvdag, vp, v)\n    h2 = 0.5 * h\n    @inbounds @simd for ip in 1:(n - 1)\n        res[2 * ip + 1] = v[ip + 1] - v[ip] - h2 * (vp[ip] + vp[ip + 1])\n        res[2 * ip] = vp[ip + 1] - vp[ip] + h2 * (force[ip] + force[ip + 1])\n    end\n    return nothing\nend\n\nfunction BVP_U0!(U0, n, tv)\n    view(U0, 1:2:(2n - 1)) .= exp.(-0.1 .* tv .* tv)\n    return view(U0, 2:2:2n) .= -0.2 .* view(U0, 1:2:(2n - 1)) .* tv\nend\n\nstruct GmresPreconditioner{JOp}\n    J::JOp\n    itmax::Int\nend\n\nfunction LinearAlgebra.mul!(y, P::GmresPreconditioner, x)\n    sol, _ = gmres(P.J, x; P.itmax)\n    return copyto!(y, sol)\nend\n\nfunction BVP_solve(n = 801, T = Float64)\n    U0 = zeros(T, 2n)\n    res = zeros(T, 2n)\n\n    h = 20.0 / (n - 1)\n    tv = collect(0:h:20.0)\n\n    tvdag = collect(0:h:20.0)\n    @views tvdag[2:n] .= (1.0 ./ tv[2:n])\n\n    force = zeros(n)\n\n    BVP_U0!(U0, n, tv)\n\n    bvpout, stats = newton_krylov!(\n        Fbvp!, U0, (force, tv, tvdag, h, n), res,\n        Solver = FgmresSolver,\n        N = (J) -> GmresPreconditioner(J, 30),\n    )\n    return (; bvpout, tv, stats)\nend\n\nBVP_solve()","category":"page"},{"location":"generated/bvp/","page":"BVP","title":"BVP","text":"","category":"page"},{"location":"generated/bvp/","page":"BVP","title":"BVP","text":"This page was generated using Literate.jl.","category":"page"}]
}
